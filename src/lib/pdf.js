/**
 * PDF generation utilities
 */

import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';

/**
 * Generate a simple text-based PDF from HTML content
 * Uses the system's html-to-pdf capabilities or falls back to text file
 */
export async function generatePdfFromHtml(html, outputPath) {
  // Ensure directory exists
  const dir = path.dirname(outputPath);
  fs.mkdirSync(dir, { recursive: true });
  
  // Try using wkhtmltopdf if available
  try {
    const tempHtmlPath = `/tmp/invoice-kraken-${Date.now()}.html`;
    fs.writeFileSync(tempHtmlPath, html);
    
    execSync(`wkhtmltopdf --quiet "${tempHtmlPath}" "${outputPath}"`, {
      stdio: 'pipe'
    });
    
    fs.unlinkSync(tempHtmlPath);
    return true;
  } catch (error) {
    // wkhtmltopdf not available, try alternatives
  }
  
  // Try using Chrome/Chromium headless
  try {
    const tempHtmlPath = `/tmp/invoice-kraken-${Date.now()}.html`;
    fs.writeFileSync(tempHtmlPath, html);
    
    // Try different Chrome paths
    const chromePaths = [
      '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome',
      '/Applications/Chromium.app/Contents/MacOS/Chromium',
      'google-chrome',
      'chromium',
    ];
    
    for (const chromePath of chromePaths) {
      try {
        execSync(
          `"${chromePath}" --headless --disable-gpu --print-to-pdf="${outputPath}" "file://${tempHtmlPath}"`,
          { stdio: 'pipe' }
        );
        fs.unlinkSync(tempHtmlPath);
        return true;
      } catch {}
    }
    
    fs.unlinkSync(tempHtmlPath);
  } catch (error) {
    // Chrome not available
  }
  
  // Fall back to saving as HTML with .pdf extension (not ideal but works)
  console.warn(`Warning: No PDF generator available. Saving as HTML: ${outputPath}`);
  fs.writeFileSync(outputPath.replace('.pdf', '.html'), html);
  return false;
}

/**
 * Generate PDF from plain text email content
 */
export async function generatePdfFromText(text, metadata, outputPath) {
  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 800px;
      margin: 40px auto;
      padding: 20px;
      line-height: 1.6;
      color: #333;
    }
    .header {
      border-bottom: 2px solid #333;
      padding-bottom: 20px;
      margin-bottom: 20px;
    }
    .header h1 {
      margin: 0 0 10px 0;
      font-size: 24px;
    }
    .meta {
      color: #666;
      font-size: 14px;
    }
    .meta p {
      margin: 5px 0;
    }
    .content {
      white-space: pre-wrap;
      font-family: inherit;
    }
    .footer {
      margin-top: 40px;
      padding-top: 20px;
      border-top: 1px solid #ccc;
      font-size: 12px;
      color: #999;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>${escapeHtml(metadata.subject || 'Invoice')}</h1>
    <div class="meta">
      <p><strong>From:</strong> ${escapeHtml(metadata.sender || 'Unknown')}</p>
      <p><strong>Date:</strong> ${escapeHtml(metadata.date || 'Unknown')}</p>
      ${metadata.invoiceNumber ? `<p><strong>Invoice #:</strong> ${escapeHtml(metadata.invoiceNumber)}</p>` : ''}
      ${metadata.amount ? `<p><strong>Amount:</strong> ${escapeHtml(metadata.amount)}</p>` : ''}
    </div>
  </div>
  <div class="content">${escapeHtml(text)}</div>
  <div class="footer">
    Generated by Invoice Kraken on ${new Date().toISOString()}
  </div>
</body>
</html>
  `.trim();
  
  return generatePdfFromHtml(html, outputPath);
}

/**
 * Escape HTML special characters
 */
function escapeHtml(text) {
  if (!text) return '';
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

/**
 * Get the invoice output path
 */
export function getInvoicePath(baseDir, date, name) {
  // Parse date
  let year, month, day;
  
  if (date instanceof Date) {
    year = date.getFullYear();
    month = String(date.getMonth() + 1).padStart(2, '0');
    day = String(date.getDate()).padStart(2, '0');
  } else if (typeof date === 'string') {
    const parsed = new Date(date);
    if (!isNaN(parsed.getTime())) {
      year = parsed.getFullYear();
      month = String(parsed.getMonth() + 1).padStart(2, '0');
      day = String(parsed.getDate()).padStart(2, '0');
    } else {
      // Try parsing YYYY-MM-DD format
      const match = date.match(/(\d{4})-(\d{2})-(\d{2})/);
      if (match) {
        [, year, month, day] = match;
      } else {
        year = new Date().getFullYear();
        month = '01';
        day = '01';
      }
    }
  } else {
    year = new Date().getFullYear();
    month = '01';
    day = '01';
  }
  
  // Sanitize filename
  const safeName = name
    .toLowerCase()
    .replace(/[^a-z0-9äöüß]+/gi, '-')
    .replace(/^-+|-+$/g, '')
    .substring(0, 50);
  
  const filename = `${day}-${safeName}.pdf`;
  
  return path.join(baseDir, String(year), month, filename);
}
